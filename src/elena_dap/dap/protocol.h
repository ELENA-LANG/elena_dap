// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated with protocol_gen.go -- do not edit this file.
//   go run scripts/protocol_gen/protocol_gen.go
//
// DAP version 1.65.0

#ifndef DAP_PROTOCOL_H
#define DAP_PROTOCOL_H

#include "optional.h"
#include "typeinfo.h"
#include "typeof.h"
#include "variant.h"

#include <string>
#include <type_traits>
#include <vector>

namespace dap 
{
   struct Request 
   {
   };

   struct Response 
   {
   };

   struct Event 
   {
   };

   // Names of checksum algorithms that may be supported by a debug adapter.
   //
   // Must be one of the following enumeration values:
   // 'MD5', 'SHA1', 'SHA256', 'timestamp'
   using ChecksumAlgorithm = string;

   // The checksum of an item calculated by the specified algorithm.
   struct Checksum {
      // The algorithm used to calculate this checksum.
      ChecksumAlgorithm algorithm = "MD5";
      // Value of the checksum, encoded as a hexadecimal value.
      string checksum;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(Checksum);


   // The event indicates that a thread has started or exited.
   struct ThreadEvent : public Event {
      // The reason for the event.
      //
      // May be one of the following enumeration values:
      // 'started', 'exited'
      string reason;
      // The identifier of the thread.
      integer threadId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ThreadEvent);

   // Describes one or more type of breakpoint a `BreakpointMode` applies to. This
   // is a non-exhaustive enumeration and may expand as future breakpoint types are
   // added.
   using BreakpointModeApplicability = string;

   // A `Source` is a descriptor for source code.
   // It is returned from the debug adapter as part of a `StackFrame` and it is
   // used by clients when specifying breakpoints.
   struct Source {
      // Additional data that a debug adapter might want to loop through the client.
      // The client should leave the data intact and persist it across sessions. The
      // client should not interpret the data.
      optional<variant<array<any>, boolean, integer, null, number, object, string>>
         adapterData;
      // The checksums associated with this file.
      optional<array<Checksum>> checksums;
      // The short name of the source. Every source returned from the debug adapter
      // has a name. When sending a source to the debug adapter this name is
      // optional.
      optional<string> name;
      // The origin of this source. For example, 'internal module', 'inlined content
      // from source map', etc.
      optional<string> origin;
      // The path of the source to be shown in the UI.
      // It is only used to locate and load the content of the source if no
      // `sourceReference` is specified (or its value is 0).
      optional<string> path;
      // A hint for how to present the source in the UI.
      // A value of `deemphasize` can be used to indicate that the source is not
      // available or that it is skipped on stepping.
      //
      // Must be one of the following enumeration values:
      // 'normal', 'emphasize', 'deemphasize'
      optional<string> presentationHint;
      // If the value > 0 the contents of the source must be retrieved through the
      // `source` request (even if a path is specified). Since a `sourceReference`
      // is only valid for a session, it can not be used to persist a source. The
      // value should be less than or equal to 2147483647 (2^31-1).
      optional<integer> sourceReference;
      // A list of sources that are related to this source. These may be the source
      // that generated this source.
      optional<array<Source>> sources;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(Source);

   // Information about a breakpoint created in `setBreakpoints`,
   // `setFunctionBreakpoints`, `setInstructionBreakpoints`, or
   // `setDataBreakpoints` requests.
   struct Breakpoint {
      // Start position of the source range covered by the breakpoint. It is
      // measured in UTF-16 code units and the client capability `columnsStartAt1`
      // determines whether it is 0- or 1-based.
      optional<integer> column;
      // End position of the source range covered by the breakpoint. It is measured
      // in UTF-16 code units and the client capability `columnsStartAt1` determines
      // whether it is 0- or 1-based. If no end line is given, then the end column
      // is assumed to be in the start line.
      optional<integer> endColumn;
      // The end line of the actual range covered by the breakpoint.
      optional<integer> endLine;
      // The identifier for the breakpoint. It is needed if breakpoint events are
      // used to update or remove breakpoints.
      optional<integer> id;
      // A memory reference to where the breakpoint is set.
      optional<string> instructionReference;
      // The start line of the actual range covered by the breakpoint.
      optional<integer> line;
      // A message about the state of the breakpoint.
      // This is shown to the user and can be used to explain why a breakpoint could
      // not be verified.
      optional<string> message;
      // The offset from the instruction reference.
      // This can be negative.
      optional<integer> offset;
      // A machine-readable explanation of why a breakpoint may not be verified. If
      // a breakpoint is verified or a specific reason is not known, the adapter
      // should omit this property. Possible values include:
      //
      // - `pending`: Indicates a breakpoint might be verified in the future, but
      // the adapter cannot verify it in the current state.
      //  - `failed`: Indicates a breakpoint was not able to be verified, and the
      //  adapter does not believe it can be verified without intervention.
      //
      // Must be one of the following enumeration values:
      // 'pending', 'failed'
      optional<string> reason;
      // The source where the breakpoint is located.
      optional<Source> source;
      // If true, the breakpoint could be set (but not necessarily at the desired
      // location).
      boolean verified;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(Breakpoint);

   // A `Scope` is a named container for variables. Optionally a scope can map to a
   // source or a range within a source.
   struct Scope {
      // Start position of the range covered by the scope. It is measured in UTF-16
      // code units and the client capability `columnsStartAt1` determines whether
      // it is 0- or 1-based.
      optional<integer> column;
      // End position of the range covered by the scope. It is measured in UTF-16
      // code units and the client capability `columnsStartAt1` determines whether
      // it is 0- or 1-based.
      optional<integer> endColumn;
      // The end line of the range covered by this scope.
      optional<integer> endLine;
      // If true, the number of variables in this scope is large or expensive to
      // retrieve.
      boolean expensive;
      // The number of indexed variables in this scope.
      // The client can use this information to present the variables in a paged UI
      // and fetch them in chunks.
      optional<integer> indexedVariables;
      // The start line of the range covered by this scope.
      optional<integer> line;
      // Name of the scope such as 'Arguments', 'Locals', or 'Registers'. This
      // string is shown in the UI as is and can be translated.
      string name;
      // The number of named variables in this scope.
      // The client can use this information to present the variables in a paged UI
      // and fetch them in chunks.
      optional<integer> namedVariables;
      // A hint for how to present this scope in the UI. If this attribute is
      // missing, the scope is shown with a generic UI.
      //
      // May be one of the following enumeration values:
      // 'arguments', 'locals', 'registers'
      optional<string> presentationHint;
      // The source for this scope.
      optional<Source> source;
      // The variables of this scope can be retrieved by passing the value of
      // `variablesReference` to the `variables` request as long as execution
      // remains suspended. See 'Lifetime of Object References' in the Overview
      // section for details.
      integer variablesReference;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(Scope);

   // Response to `scopes` request.
   struct ScopesResponse : public Response {
      // The scopes of the stack frame. If the array has length zero, there are no
      // scopes available.
      array<Scope> scopes;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ScopesResponse);

   // The request returns the variable scopes for a given stack frame ID.
   struct ScopesRequest : public Request {
      using Response = ScopesResponse;
      // Retrieve the scopes for the stack frame identified by `frameId`. The
      // `frameId` must have been obtained in the current suspended state. See
      // 'Lifetime of Object References' in the Overview section for details.
      integer frameId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ScopesRequest);

   // Response to `pause` request. This is just an acknowledgement, so no body
   // field is required.
   struct PauseResponse : public Response {};

   DAP_DECLARE_STRUCT_TYPEINFO(PauseResponse);

   // The request suspends the debuggee.
   // The debug adapter first sends the response and then a `stopped` event (with
   // reason `pause`) after the thread has been paused successfully.
   struct PauseRequest : public Request {
      using Response = PauseResponse;
      // Pause execution for this thread.
      integer threadId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(PauseRequest);

   // Response to `continue` request.
   struct ContinueResponse : public Response {
      // The value true (or a missing property) signals to the client that all
      // threads have been resumed. The value false indicates that not all threads
      // were resumed.
      optional<boolean> allThreadsContinued;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ContinueResponse);

   // The request resumes execution of all threads. If the debug adapter supports
   // single thread execution (see capability
   // `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument
   // to true resumes only the specified thread. If not all threads were resumed,
   // the `allThreadsContinued` attribute of the response should be set to false.
   struct ContinueRequest : public Request {
      using Response = ContinueResponse;
      // If this flag is true, execution is resumed only for the thread with given
      // `threadId`.
      optional<boolean> singleThread;
      // Specifies the active thread. If the debug adapter supports single thread
      // execution (see `supportsSingleThreadExecutionRequests`) and the argument
      // `singleThread` is true, only the thread with this ID is resumed.
      integer threadId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ContinueRequest);

   // Response to `next` request. This is just an acknowledgement, so no body field
   // is required.
   struct NextResponse : public Response {};

   DAP_DECLARE_STRUCT_TYPEINFO(NextResponse);

   // The granularity of one 'step' in the stepping requests `next`, `stepIn`,
   // `stepOut`, and `stepBack`.
   //
   // Must be one of the following enumeration values:
   // 'statement', 'line', 'instruction'
   using SteppingGranularity = string;

   // The request executes one step (in the given granularity) for the specified
   // thread and allows all other threads to run freely by resuming them. If the
   // debug adapter supports single thread execution (see capability
   // `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument
   // to true prevents other suspended threads from resuming. The debug adapter
   // first sends the response and then a `stopped` event (with reason `step`)
   // after the step has completed.
   struct NextRequest : public Request {
      using Response = NextResponse;
      // Stepping granularity. If no granularity is specified, a granularity of
      // `statement` is assumed.
      optional<SteppingGranularity> granularity;
      // If this flag is true, all other suspended threads are not resumed.
      optional<boolean> singleThread;
      // Specifies the thread for which to resume execution for one step (of the
      // given granularity).
      integer threadId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(NextRequest);

   // Provides formatting information for a value.
   struct ValueFormat {
      // Display the value in hex.
      optional<boolean> hex;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ValueFormat);

   // Properties of a variable that can be used to determine how to render the
   // variable in the UI.
   struct VariablePresentationHint {
      // Set of attributes represented as an array of strings. Before introducing
      // additional values, try to use the listed values.
      optional<array<string>> attributes;
      // The kind of variable. Before introducing additional values, try to use the
      // listed values.
      //
      // May be one of the following enumeration values:
      // 'property', 'method', 'class', 'data', 'event', 'baseClass', 'innerClass',
      // 'interface', 'mostDerivedClass', 'virtual', 'dataBreakpoint'
      optional<string> kind;
      // If true, clients can present the variable with a UI that supports a
      // specific gesture to trigger its evaluation. This mechanism can be used for
      // properties that require executing code when retrieving their value and
      // where the code execution can be expensive and/or produce side-effects. A
      // typical example are properties based on a getter function. Please note that
      // in addition to the `lazy` flag, the variable's `variablesReference` is
      // expected to refer to a variable that will provide the value through another
      // `variable` request.
      optional<boolean> lazy;
      // Visibility of variable. Before introducing additional values, try to use
      // the listed values.
      //
      // May be one of the following enumeration values:
      // 'public', 'private', 'protected', 'internal', 'final'
      optional<string> visibility;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(VariablePresentationHint);

   // A Variable is a name/value pair.
   // The `type` attribute is shown if space permits or when hovering over the
   // variable's name. The `kind` attribute is used to render additional properties
   // of the variable, e.g. different icons can be used to indicate that a variable
   // is public or private. If the value is structured (has children), a handle is
   // provided to retrieve the children with the `variables` request. If the number
   // of named or indexed children is large, the numbers should be returned via the
   // `namedVariables` and `indexedVariables` attributes. The client can use this
   // information to present the children in a paged UI and fetch them in chunks.
   struct Variable {
      // The evaluatable name of this variable which can be passed to the `evaluate`
      // request to fetch the variable's value.
      optional<string> evaluateName;
      // The number of indexed child variables.
      // The client can use this information to present the children in a paged UI
      // and fetch them in chunks.
      optional<integer> indexedVariables;
      // A memory reference associated with this variable.
      // For pointer type variables, this is generally a reference to the memory
      // address contained in the pointer. For executable data, this reference may
      // later be used in a `disassemble` request. This attribute may be returned by
      // a debug adapter if corresponding capability `supportsMemoryReferences` is
      // true.
      optional<string> memoryReference;
      // The variable's name.
      string name;
      // The number of named child variables.
      // The client can use this information to present the children in a paged UI
      // and fetch them in chunks.
      optional<integer> namedVariables;
      // Properties of a variable that can be used to determine how to render the
      // variable in the UI.
      optional<VariablePresentationHint> presentationHint;
      // The type of the variable's value. Typically shown in the UI when hovering
      // over the value. This attribute should only be returned by a debug adapter
      // if the corresponding capability `supportsVariableType` is true.
      optional<string> type;
      // The variable's value.
      // This can be a multi-line text, e.g. for a function the body of a function.
      // For structured variables (which do not have a simple value), it is
      // recommended to provide a one-line representation of the structured object.
      // This helps to identify the structured object in the collapsed state when
      // its children are not yet visible. An empty string can be used if no value
      // should be shown in the UI.
      string value;
      // If `variablesReference` is > 0, the variable is structured and its children
      // can be retrieved by passing `variablesReference` to the `variables` request
      // as long as execution remains suspended. See 'Lifetime of Object References'
      // in the Overview section for details.
      integer variablesReference;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(Variable);

   // Response to `variables` request.
   struct VariablesResponse : public Response {
      // All (or a range) of variables for the given variable reference.
      array<Variable> variables;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(VariablesResponse);

   // Retrieves all child variables for the given variable reference.
   // A filter can be used to limit the fetched children to either named or indexed
   // children.
   struct VariablesRequest : public Request {
      using Response = VariablesResponse;
      // The number of variables to return. If count is missing or 0, all variables
      // are returned. The attribute is only honored by a debug adapter if the
      // corresponding capability `supportsVariablePaging` is true.
      optional<integer> count;
      // Filter to limit the child variables to either named or indexed. If omitted,
      // both types are fetched.
      //
      // Must be one of the following enumeration values:
      // 'indexed', 'named'
      optional<string> filter;
      // Specifies details on how to format the Variable values.
      // The attribute is only honored by a debug adapter if the corresponding
      // capability `supportsValueFormattingOptions` is true.
      optional<ValueFormat> format;
      // The index of the first variable to return; if omitted children start at 0.
      // The attribute is only honored by a debug adapter if the corresponding
      // capability `supportsVariablePaging` is true.
      optional<integer> start;
      // The variable for which to retrieve its children. The `variablesReference`
      // must have been obtained in the current suspended state. See 'Lifetime of
      // Object References' in the Overview section for details.
      integer variablesReference;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(VariablesRequest);

   // A `BreakpointMode` is provided as a option when setting breakpoints on
   // sources or instructions.
   struct BreakpointMode {
      // Describes one or more type of breakpoint this mode applies to.
      array<BreakpointModeApplicability> appliesTo;
      // A help text providing additional information about the breakpoint mode.
      // This string is typically shown as a hover and can be translated.
      optional<string> description;
      // The name of the breakpoint mode. This is shown in the UI.
      string label;
      // The internal ID of the mode. This value is passed to the `setBreakpoints`
      // request.
      string mode;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(BreakpointMode);

   // A `ColumnDescriptor` specifies what module attribute to show in a column of
   // the modules view, how to format it, and what the column's label should be. It
   // is only used if the underlying UI actually supports this level of
   // customization.
   struct ColumnDescriptor {
      // Name of the attribute rendered in this column.
      string attributeName;
      // Format to use for the rendered values in this column. TBD how the format
      // strings looks like.
      optional<string> format;
      // Header UI label of column.
      string label;
      // Datatype of values in this column. Defaults to `string` if not specified.
      //
      // Must be one of the following enumeration values:
      // 'string', 'number', 'boolean', 'unixTimestampUTC'
      optional<string> type;
      // Width of this column in characters (hint only).
      optional<integer> width;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ColumnDescriptor);

   // An `ExceptionBreakpointsFilter` is shown in the UI as an filter option for
   // configuring how exceptions are dealt with.
   struct ExceptionBreakpointsFilter {
      // A help text providing information about the condition. This string is shown
      // as the placeholder text for a text box and can be translated.
      optional<string> conditionDescription;
      // Initial value of the filter option. If not specified a value false is
      // assumed.
      optional<boolean> def;
      // A help text providing additional information about the exception filter.
      // This string is typically shown as a hover and can be translated.
      optional<string> description;
      // The internal ID of the filter option. This value is passed to the
      // `setExceptionBreakpoints` request.
      string filter;
      // The name of the filter option. This is shown in the UI.
      string label;
      // Controls whether a condition can be specified for this filter option. If
      // false or missing, a condition can not be set.
      optional<boolean> supportsCondition;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ExceptionBreakpointsFilter);

   // Response to `initialize` request.
   struct InitializeResponse : public Response {
      // The set of additional module information exposed by the debug adapter.
      optional<array<ColumnDescriptor>> additionalModuleColumns;
      // Modes of breakpoints supported by the debug adapter, such as 'hardware' or
      // 'software'. If present, the client may allow the user to select a mode and
      // include it in its `setBreakpoints` request.
      //
      // Clients may present the first applicable mode in this array as the
      // 'default' mode in gestures that set breakpoints.
      optional<array<BreakpointMode>> breakpointModes;
      // The set of characters that should trigger completion in a REPL. If not
      // specified, the UI should assume the `.` character.
      optional<array<string>> completionTriggerCharacters;
      // Available exception filter options for the `setExceptionBreakpoints`
      // request.
      optional<array<ExceptionBreakpointsFilter>> exceptionBreakpointFilters;
      // The debug adapter supports the `suspendDebuggee` attribute on the
      // `disconnect` request.
      optional<boolean> supportSuspendDebuggee;
      // The debug adapter supports the `terminateDebuggee` attribute on the
      // `disconnect` request.
      optional<boolean> supportTerminateDebuggee;
      // Checksum algorithms supported by the debug adapter.
      optional<array<ChecksumAlgorithm>> supportedChecksumAlgorithms;
      // The debug adapter supports the `breakpointLocations` request.
      optional<boolean> supportsBreakpointLocationsRequest;
      // The debug adapter supports the `cancel` request.
      optional<boolean> supportsCancelRequest;
      // The debug adapter supports the `clipboard` context value in the `evaluate`
      // request.
      optional<boolean> supportsClipboardContext;
      // The debug adapter supports the `completions` request.
      optional<boolean> supportsCompletionsRequest;
      // The debug adapter supports conditional breakpoints.
      optional<boolean> supportsConditionalBreakpoints;
      // The debug adapter supports the `configurationDone` request.
      optional<boolean> supportsConfigurationDoneRequest;
      // The debug adapter supports data breakpoints.
      optional<boolean> supportsDataBreakpoints;
      // The debug adapter supports the delayed loading of parts of the stack, which
      // requires that both the `startFrame` and `levels` arguments and the
      // `totalFrames` result of the `stackTrace` request are supported.
      optional<boolean> supportsDelayedStackTraceLoading;
      // The debug adapter supports the `disassemble` request.
      optional<boolean> supportsDisassembleRequest;
      // The debug adapter supports a (side effect free) `evaluate` request for data
      // hovers.
      optional<boolean> supportsEvaluateForHovers;
      // The debug adapter supports `filterOptions` as an argument on the
      // `setExceptionBreakpoints` request.
      optional<boolean> supportsExceptionFilterOptions;
      // The debug adapter supports the `exceptionInfo` request.
      optional<boolean> supportsExceptionInfoRequest;
      // The debug adapter supports `exceptionOptions` on the
      // `setExceptionBreakpoints` request.
      optional<boolean> supportsExceptionOptions;
      // The debug adapter supports function breakpoints.
      optional<boolean> supportsFunctionBreakpoints;
      // The debug adapter supports the `gotoTargets` request.
      optional<boolean> supportsGotoTargetsRequest;
      // The debug adapter supports breakpoints that break execution after a
      // specified number of hits.
      optional<boolean> supportsHitConditionalBreakpoints;
      // The debug adapter supports adding breakpoints based on instruction
      // references.
      optional<boolean> supportsInstructionBreakpoints;
      // The debug adapter supports the `loadedSources` request.
      optional<boolean> supportsLoadedSourcesRequest;
      // The debug adapter supports log points by interpreting the `logMessage`
      // attribute of the `SourceBreakpoint`.
      optional<boolean> supportsLogPoints;
      // The debug adapter supports the `modules` request.
      optional<boolean> supportsModulesRequest;
      // The debug adapter supports the `readMemory` request.
      optional<boolean> supportsReadMemoryRequest;
      // The debug adapter supports restarting a frame.
      optional<boolean> supportsRestartFrame;
      // The debug adapter supports the `restart` request. In this case a client
      // should not implement `restart` by terminating and relaunching the adapter
      // but by calling the `restart` request.
      optional<boolean> supportsRestartRequest;
      // The debug adapter supports the `setExpression` request.
      optional<boolean> supportsSetExpression;
      // The debug adapter supports setting a variable to a value.
      optional<boolean> supportsSetVariable;
      // The debug adapter supports the `singleThread` property on the execution
      // requests (`continue`, `next`, `stepIn`, `stepOut`, `reverseContinue`,
      // `stepBack`).
      optional<boolean> supportsSingleThreadExecutionRequests;
      // The debug adapter supports stepping back via the `stepBack` and
      // `reverseContinue` requests.
      optional<boolean> supportsStepBack;
      // The debug adapter supports the `stepInTargets` request.
      optional<boolean> supportsStepInTargetsRequest;
      // The debug adapter supports stepping granularities (argument `granularity`)
      // for the stepping requests.
      optional<boolean> supportsSteppingGranularity;
      // The debug adapter supports the `terminate` request.
      optional<boolean> supportsTerminateRequest;
      // The debug adapter supports the `terminateThreads` request.
      optional<boolean> supportsTerminateThreadsRequest;
      // The debug adapter supports a `format` attribute on the `stackTrace`,
      // `variables`, and `evaluate` requests.
      optional<boolean> supportsValueFormattingOptions;
      // The debug adapter supports the `writeMemory` request.
      optional<boolean> supportsWriteMemoryRequest;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(InitializeResponse);

   struct InitializeRequest : public Request
   {
      using Response = InitializeResponse;
      // The ID of the debug adapter.
      string adapterID;
      // The ID of the client using this adapter.
      optional<string> clientID;
      // The human-readable name of the client using this adapter.
      optional<string> clientName;
      // If true all column numbers are 1-based (default).
      optional<boolean> columnsStartAt1;
      // If true all line numbers are 1-based (default).
      optional<boolean> linesStartAt1;
      // The ISO-639 locale of the client using this adapter, e.g. en-US or de-CH.
      optional<string> locale;
      // Determines in what format paths are specified. The default is `path`, which
      // is the native format.
      //
      // May be one of the following enumeration values:
      // 'path', 'uri'
      optional<string> pathFormat;
      // Client supports the `argsCanBeInterpretedByShell` attribute on the
      // `runInTerminal` request.
      optional<boolean> supportsArgsCanBeInterpretedByShell;
      // Client supports the `invalidated` event.
      optional<boolean> supportsInvalidatedEvent;
      // Client supports the `memory` event.
      optional<boolean> supportsMemoryEvent;
      // Client supports memory references.
      optional<boolean> supportsMemoryReferences;
      // Client supports progress reporting.
      optional<boolean> supportsProgressReporting;
      // Client supports the `runInTerminal` request.
      optional<boolean> supportsRunInTerminalRequest;
      // Client supports the `startDebugging` request.
      optional<boolean> supportsStartDebuggingRequest;
      // Client supports the paging of variables.
      optional<boolean> supportsVariablePaging;
      // Client supports the `type` attribute for variables.
      optional<boolean> supportsVariableType;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(InitializeRequest);

   // This event indicates that the debug adapter is ready to accept configuration
   // requests (e.g. `setBreakpoints`, `setExceptionBreakpoints`). A debug adapter
   // is expected to send this event when it is ready to accept configuration
   // requests (but not before the `initialize` request has finished). The sequence
   // of events/requests is as follows:
   // - adapters sends `initialized` event (after the `initialize` request has
   // returned)
   // - client sends zero or more `setBreakpoints` requests
   // - client sends one `setFunctionBreakpoints` request (if corresponding
   // capability `supportsFunctionBreakpoints` is true)
   // - client sends a `setExceptionBreakpoints` request if one or more
   // `exceptionBreakpointFilters` have been defined (or if
   // `supportsConfigurationDoneRequest` is not true)
   // - client sends other future configuration requests
   // - client sends one `configurationDone` request to indicate the end of the
   // configuration.
   struct InitializedEvent : public Event {};

   DAP_DECLARE_STRUCT_TYPEINFO(InitializedEvent);

   // The event indicates that the execution of the debuggee has stopped due to
   // some condition. This can be caused by a breakpoint previously set, a stepping
   // request has completed, by executing a debugger statement etc.
   struct StoppedEvent : public Event {
      // If `allThreadsStopped` is true, a debug adapter can announce that all
      // threads have stopped.
      // - The client should use this information to enable that all threads can be
      // expanded to access their stacktraces.
      // - If the attribute is missing or false, only the thread with the given
      // `threadId` can be expanded.
      optional<boolean> allThreadsStopped;
      // The full reason for the event, e.g. 'Paused on exception'. This string is
      // shown in the UI as is and can be translated.
      optional<string> description;
      // Ids of the breakpoints that triggered the event. In most cases there is
      // only a single breakpoint but here are some examples for multiple
      // breakpoints:
      // - Different types of breakpoints map to the same location.
      // - Multiple source breakpoints get collapsed to the same instruction by the
      // compiler/runtime.
      // - Multiple function breakpoints with different function names map to the
      // same location.
      optional<array<integer>> hitBreakpointIds;
      // A value of true hints to the client that this event should not change the
      // focus.
      optional<boolean> preserveFocusHint;
      // The reason for the event.
      // For backward compatibility this string is shown in the UI if the
      // `description` attribute is missing (but it must not be translated).
      //
      // May be one of the following enumeration values:
      // 'step', 'breakpoint', 'exception', 'pause', 'entry', 'goto', 'function
      // breakpoint', 'data breakpoint', 'instruction breakpoint'
      string reason;
      // Additional information. E.g. if reason is `exception`, text contains the
      // exception name. This string is shown in the UI.
      optional<string> text;
      // The thread which was stopped.
      optional<integer> threadId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(StoppedEvent);

   // A Thread
   struct Thread {
      // Unique identifier for the thread.
      integer id;
      // The name of the thread.
      string name;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(Thread);

   // Response to `threads` request.
   struct ThreadsResponse : public Response {
      // All threads.
      array<Thread> threads;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ThreadsResponse);

   // The request retrieves a list of all threads.
   struct ThreadsRequest : public Request {
      using Response = ThreadsResponse;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ThreadsRequest);

   // A Stackframe contains the source location.
   struct StackFrame {
      // Indicates whether this frame can be restarted with the `restart` request.
      // Clients should only use this if the debug adapter supports the `restart`
      // request and the corresponding capability `supportsRestartRequest` is true.
      // If a debug adapter has this capability, then `canRestart` defaults to
      // `true` if the property is absent.
      optional<boolean> canRestart;
      // Start position of the range covered by the stack frame. It is measured in
      // UTF-16 code units and the client capability `columnsStartAt1` determines
      // whether it is 0- or 1-based. If attribute `source` is missing or doesn't
      // exist, `column` is 0 and should be ignored by the client.
      integer column;
      // End position of the range covered by the stack frame. It is measured in
      // UTF-16 code units and the client capability `columnsStartAt1` determines
      // whether it is 0- or 1-based.
      optional<integer> endColumn;
      // The end line of the range covered by the stack frame.
      optional<integer> endLine;
      // An identifier for the stack frame. It must be unique across all threads.
      // This id can be used to retrieve the scopes of the frame with the `scopes`
      // request or to restart the execution of a stack frame.
      integer id;
      // A memory reference for the current instruction pointer in this frame.
      optional<string> instructionPointerReference;
      // The line within the source of the frame. If the source attribute is missing
      // or doesn't exist, `line` is 0 and should be ignored by the client.
      integer line;
      // The module associated with this frame, if any.
      optional<variant<integer, string>> moduleId;
      // The name of the stack frame, typically a method name.
      string name;
      // A hint for how to present this frame in the UI.
      // A value of `label` can be used to indicate that the frame is an artificial
      // frame that is used as a visual label or separator. A value of `subtle` can
      // be used to change the appearance of a frame in a 'subtle' way.
      //
      // Must be one of the following enumeration values:
      // 'normal', 'label', 'subtle'
      optional<string> presentationHint;
      // The source of the frame.
      optional<Source> source;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(StackFrame);

   // Provides formatting information for a stack frame.
   struct StackFrameFormat : public ValueFormat {
      // Includes all stack frames, including those the debug adapter might
      // otherwise hide.
      optional<boolean> includeAll;
      // Displays the line number of the stack frame.
      optional<boolean> line;
      // Displays the module of the stack frame.
      optional<boolean> module;
      // Displays the names of parameters for the stack frame.
      optional<boolean> parameterNames;
      // Displays the types of parameters for the stack frame.
      optional<boolean> parameterTypes;
      // Displays the values of parameters for the stack frame.
      optional<boolean> parameterValues;
      // Displays parameters for the stack frame.
      optional<boolean> parameters;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(StackFrameFormat);

   // Response to `stackTrace` request.
   struct StackTraceResponse : public Response {
      // The frames of the stack frame. If the array has length zero, there are no
      // stack frames available. This means that there is no location information
      // available.
      array<StackFrame> stackFrames;
      // The total number of frames available in the stack. If omitted or if
      // `totalFrames` is larger than the available frames, a client is expected to
      // request frames until a request returns less frames than requested (which
      // indicates the end of the stack). Returning monotonically increasing
      // `totalFrames` values for subsequent requests can be used to enforce paging
      // in the client.
      optional<integer> totalFrames;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(StackTraceResponse);

   // The request returns a stacktrace from the current execution state of a given
   // thread. A client can request all stack frames by omitting the startFrame and
   // levels arguments. For performance-conscious clients and if the corresponding
   // capability `supportsDelayedStackTraceLoading` is true, stack frames can be
   // retrieved in a piecemeal way with the `startFrame` and `levels` arguments.
   // The response of the `stackTrace` request may contain a `totalFrames` property
   // that hints at the total number of frames in the stack. If a client needs this
   // total number upfront, it can issue a request for a single (first) frame and
   // depending on the value of `totalFrames` decide how to proceed. In any case a
   // client should be prepared to receive fewer frames than requested, which is an
   // indication that the end of the stack has been reached.
   struct StackTraceRequest : public Request {
      using Response = StackTraceResponse;
      // Specifies details on how to format the stack frames.
      // The attribute is only honored by a debug adapter if the corresponding
      // capability `supportsValueFormattingOptions` is true.
      optional<StackFrameFormat> format;
      // The maximum number of frames to return. If levels is not specified or 0,
      // all frames are returned.
      optional<integer> levels;
      // The index of the first frame to return; if omitted frames start at 0.
      optional<integer> startFrame;
      // Retrieve the stacktrace for this thread.
      integer threadId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(StackTraceRequest);

   // Response to `stepBack` request. This is just an acknowledgement, so no body
   // field is required.
   struct StepBackResponse : public Response {};

   DAP_DECLARE_STRUCT_TYPEINFO(StepBackResponse);

   // The request executes one backward step (in the given granularity) for the
   // specified thread and allows all other threads to run backward freely by
   // resuming them. If the debug adapter supports single thread execution (see
   // capability `supportsSingleThreadExecutionRequests`), setting the
   // `singleThread` argument to true prevents other suspended threads from
   // resuming. The debug adapter first sends the response and then a `stopped`
   // event (with reason `step`) after the step has completed. Clients should only
   // call this request if the corresponding capability `supportsStepBack` is true.
   struct StepBackRequest : public Request {
      using Response = StepBackResponse;
      // Stepping granularity to step. If no granularity is specified, a granularity
      // of `statement` is assumed.
      optional<SteppingGranularity> granularity;
      // If this flag is true, all other suspended threads are not resumed.
      optional<boolean> singleThread;
      // Specifies the thread for which to resume execution for one step backwards
      // (of the given granularity).
      integer threadId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(StepBackRequest);

   // Response to `stepIn` request. This is just an acknowledgement, so no body
   // field is required.
   struct StepInResponse : public Response {};

   DAP_DECLARE_STRUCT_TYPEINFO(StepInResponse);

   // The request resumes the given thread to step into a function/method and
   // allows all other threads to run freely by resuming them. If the debug adapter
   // supports single thread execution (see capability
   // `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument
   // to true prevents other suspended threads from resuming. If the request cannot
   // step into a target, `stepIn` behaves like the `next` request. The debug
   // adapter first sends the response and then a `stopped` event (with reason
   // `step`) after the step has completed. If there are multiple function/method
   // calls (or other targets) on the source line, the argument `targetId` can be
   // used to control into which target the `stepIn` should occur. The list of
   // possible targets for a given source line can be retrieved via the
   // `stepInTargets` request.
   struct StepInRequest : public Request {
      using Response = StepInResponse;
      // Stepping granularity. If no granularity is specified, a granularity of
      // `statement` is assumed.
      optional<SteppingGranularity> granularity;
      // If this flag is true, all other suspended threads are not resumed.
      optional<boolean> singleThread;
      // Id of the target to step into.
      optional<integer> targetId;
      // Specifies the thread for which to resume execution for one step-into (of
      // the given granularity).
      integer threadId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(StepInRequest);

   // Response to `stepOut` request. This is just an acknowledgement, so no body
   // field is required.
   struct StepOutResponse : public Response {};

   DAP_DECLARE_STRUCT_TYPEINFO(StepOutResponse);

   // The request resumes the given thread to step out (return) from a
   // function/method and allows all other threads to run freely by resuming them.
   // If the debug adapter supports single thread execution (see capability
   // `supportsSingleThreadExecutionRequests`), setting the `singleThread` argument
   // to true prevents other suspended threads from resuming. The debug adapter
   // first sends the response and then a `stopped` event (with reason `step`)
   // after the step has completed.
   struct StepOutRequest : public Request {
      using Response = StepOutResponse;
      // Stepping granularity. If no granularity is specified, a granularity of
      // `statement` is assumed.
      optional<SteppingGranularity> granularity;
      // If this flag is true, all other suspended threads are not resumed.
      optional<boolean> singleThread;
      // Specifies the thread for which to resume execution for one step-out (of the
      // given granularity).
      integer threadId;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(StepOutRequest);

   // Response to `setBreakpoints` request.
   // Returned is information about each breakpoint created by this request.
   // This includes the actual code location and whether the breakpoint could be
   // verified. The breakpoints returned are in the same order as the elements of
   // the `breakpoints` (or the deprecated `lines`) array in the arguments.
   struct SetBreakpointsResponse : public Response {
      // Information about the breakpoints.
      // The array elements are in the same order as the elements of the
      // `breakpoints` (or the deprecated `lines`) array in the arguments.
      array<Breakpoint> breakpoints;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(SetBreakpointsResponse);

   // Properties of a breakpoint or logpoint passed to the `setBreakpoints`
   // request.
   struct SourceBreakpoint {
      // Start position within source line of the breakpoint or logpoint. It is
      // measured in UTF-16 code units and the client capability `columnsStartAt1`
      // determines whether it is 0- or 1-based.
      optional<integer> column;
      // The expression for conditional breakpoints.
      // It is only honored by a debug adapter if the corresponding capability
      // `supportsConditionalBreakpoints` is true.
      optional<string> condition;
      // The expression that controls how many hits of the breakpoint are ignored.
      // The debug adapter is expected to interpret the expression as needed.
      // The attribute is only honored by a debug adapter if the corresponding
      // capability `supportsHitConditionalBreakpoints` is true. If both this
      // property and `condition` are specified, `hitCondition` should be evaluated
      // only if the `condition` is met, and the debug adapter should stop only if
      // both conditions are met.
      optional<string> hitCondition;
      // The source line of the breakpoint or logpoint.
      integer line;
      // If this attribute exists and is non-empty, the debug adapter must not
      // 'break' (stop) but log the message instead. Expressions within `{}` are
      // interpolated. The attribute is only honored by a debug adapter if the
      // corresponding capability `supportsLogPoints` is true. If either
      // `hitCondition` or `condition` is specified, then the message should only be
      // logged if those conditions are met.
      optional<string> logMessage;
      // The mode of this breakpoint. If defined, this must be one of the
      // `breakpointModes` the debug adapter advertised in its `Capabilities`.
      optional<string> mode;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(SourceBreakpoint);

   // Sets multiple breakpoints for a single source and clears all previous
   // breakpoints in that source. To clear all breakpoint for a source, specify an
   // empty array. When a breakpoint is hit, a `stopped` event (with reason
   // `breakpoint`) is generated.
   struct SetBreakpointsRequest : public Request {
      using Response = SetBreakpointsResponse;
      // The code locations of the breakpoints.
      optional<array<SourceBreakpoint>> breakpoints;
      // Deprecated: The code locations of the breakpoints.
      optional<array<integer>> lines;
      // The source location of the breakpoints; either `source.path` or
      // `source.sourceReference` must be specified.
      Source source;
      // A value of true indicates that the underlying source has been modified
      // which results in new breakpoint locations.
      optional<boolean> sourceModified;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(SetBreakpointsRequest);

   // Response to `setExceptionBreakpoints` request.
   // The response contains an array of `Breakpoint` objects with information about
   // each exception breakpoint or filter. The `Breakpoint` objects are in the same
   // order as the elements of the `filters`, `filterOptions`, `exceptionOptions`
   // arrays given as arguments. If both `filters` and `filterOptions` are given,
   // the returned array must start with `filters` information first, followed by
   // `filterOptions` information. The `verified` property of a `Breakpoint` object
   // signals whether the exception breakpoint or filter could be successfully
   // created and whether the condition is valid. In case of an error the `message`
   // property explains the problem. The `id` property can be used to introduce a
   // unique ID for the exception breakpoint or filter so that it can be updated
   // subsequently by sending breakpoint events. For backward compatibility both
   // the `breakpoints` array and the enclosing `body` are optional. If these
   // elements are missing a client is not able to show problems for individual
   // exception breakpoints or filters.
   struct SetExceptionBreakpointsResponse : public Response {
      // Information about the exception breakpoints or filters.
      // The breakpoints returned are in the same order as the elements of the
      // `filters`, `filterOptions`, `exceptionOptions` arrays in the arguments. If
      // both `filters` and `filterOptions` are given, the returned array must start
      // with `filters` information first, followed by `filterOptions` information.
      optional<array<Breakpoint>> breakpoints;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(SetExceptionBreakpointsResponse);

   // This enumeration defines all possible conditions when a thrown exception
   // should result in a break. never: never breaks, always: always breaks,
   // unhandled: breaks when exception unhandled,
   // userUnhandled: breaks if the exception is not handled by user code.
   //
   // Must be one of the following enumeration values:
   // 'never', 'always', 'unhandled', 'userUnhandled'
   using ExceptionBreakMode = string;

   // An `ExceptionPathSegment` represents a segment in a path that is used to
   // match leafs or nodes in a tree of exceptions. If a segment consists of more
   // than one name, it matches the names provided if `negate` is false or missing,
   // or it matches anything except the names provided if `negate` is true.
   struct ExceptionPathSegment {
      // Depending on the value of `negate` the names that should match or not
      // match.
      array<string> names;
      // If false or missing this segment matches the names provided, otherwise it
      // matches anything except the names provided.
      optional<boolean> negate;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ExceptionPathSegment);

   // An `ExceptionOptions` assigns configuration options to a set of exceptions.
   struct ExceptionOptions {
      // Condition when a thrown exception should result in a break.
      ExceptionBreakMode breakMode = "never";
      // A path that selects a single or multiple exceptions in a tree. If `path` is
      // missing, the whole tree is selected. By convention the first segment of the
      // path is a category that is used to group exceptions in the UI.
      optional<array<ExceptionPathSegment>> path;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ExceptionOptions);

   // An `ExceptionFilterOptions` is used to specify an exception filter together
   // with a condition for the `setExceptionBreakpoints` request.
   struct ExceptionFilterOptions {
      // An expression for conditional exceptions.
      // The exception breaks into the debugger if the result of the condition is
      // true.
      optional<string> condition;
      // ID of an exception filter returned by the `exceptionBreakpointFilters`
      // capability.
      string filterId;
      // The mode of this exception breakpoint. If defined, this must be one of the
      // `breakpointModes` the debug adapter advertised in its `Capabilities`.
      optional<string> mode;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ExceptionFilterOptions);

   // The request configures the debugger's response to thrown exceptions. Each of
   // the `filters`, `filterOptions`, and `exceptionOptions` in the request are
   // independent configurations to a debug adapter indicating a kind of exception
   // to catch. An exception thrown in a program should result in a `stopped` event
   // from the debug adapter (with reason `exception`) if any of the configured
   // filters match. Clients should only call this request if the corresponding
   // capability `exceptionBreakpointFilters` returns one or more filters.
   struct SetExceptionBreakpointsRequest : public Request {
      using Response = SetExceptionBreakpointsResponse;
      // Configuration options for selected exceptions.
      // The attribute is only honored by a debug adapter if the corresponding
      // capability `supportsExceptionOptions` is true.
      optional<array<ExceptionOptions>> exceptionOptions;
      // Set of exception filters and their options. The set of all possible
      // exception filters is defined by the `exceptionBreakpointFilters`
      // capability. This attribute is only honored by a debug adapter if the
      // corresponding capability `supportsExceptionFilterOptions` is true. The
      // `filter` and `filterOptions` sets are additive.
      optional<array<ExceptionFilterOptions>> filterOptions;
      // Set of exception filters specified by their ID. The set of all possible
      // exception filters is defined by the `exceptionBreakpointFilters`
      // capability. The `filter` and `filterOptions` sets are additive.
      array<string> filters;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(SetExceptionBreakpointsRequest);

   // Response to `source` request.
   struct SourceResponse : public Response {
      // Content of the source reference.
      string content;
      // Content type (MIME type) of the source.
      optional<string> mimeType;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(SourceResponse);

   // The request retrieves the source code for a given source reference.
   struct SourceRequest : public Request {
      using Response = SourceResponse;
      // Specifies the source content to load. Either `source.path` or
      // `source.sourceReference` must be specified.
      optional<Source> source;
      // The reference to the source. This is the same as `source.sourceReference`.
      // This is provided for backward compatibility since old clients do not
      // understand the `source` attribute.
      integer sourceReference;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(SourceRequest);

   // Response to `launch` request. This is just an acknowledgement, so no body
   // field is required.
   struct LaunchResponse : public Response {};

   DAP_DECLARE_STRUCT_TYPEINFO(LaunchResponse);

   // This launch request is sent from the client to the debug adapter to start the
   // debuggee with or without debugging (if `noDebug` is true). Since launching is
   // debugger/runtime specific, the arguments for this request are not part of
   // this specification.
   struct LaunchRequest : public Request {
      using Response = LaunchResponse;
      // Arbitrary data from the previous, restarted session.
      // The data is sent as the `restart` attribute of the `terminated` event.
      // The client should leave the data intact.
      optional<variant<array<any>, boolean, integer, null, number, object, string>>
         restart;
      // If true, the launch request should launch the program without enabling
      // debugging.
      optional<boolean> noDebug;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(LaunchRequest);

   // Response to `disconnect` request. This is just an acknowledgement, so no body
   // field is required.
   struct DisconnectResponse : public Response {};

   DAP_DECLARE_STRUCT_TYPEINFO(DisconnectResponse);

   // The `disconnect` request asks the debug adapter to disconnect from the
   // debuggee (thus ending the debug session) and then to shut down itself (the
   // debug adapter). In addition, the debug adapter must terminate the debuggee if
   // it was started with the `launch` request. If an `attach` request was used to
   // connect to the debuggee, then the debug adapter must not terminate the
   // debuggee. This implicit behavior of when to terminate the debuggee can be
   // overridden with the `terminateDebuggee` argument (which is only supported by
   // a debug adapter if the corresponding capability `supportTerminateDebuggee` is
   // true).
   struct DisconnectRequest : public Request {
      using Response = DisconnectResponse;
      // A value of true indicates that this `disconnect` request is part of a
      // restart sequence.
      optional<boolean> restart;
      // Indicates whether the debuggee should stay suspended when the debugger is
      // disconnected. If unspecified, the debuggee should resume execution. The
      // attribute is only honored by a debug adapter if the corresponding
      // capability `supportSuspendDebuggee` is true.
      optional<boolean> suspendDebuggee;
      // Indicates whether the debuggee should be terminated when the debugger is
      // disconnected. If unspecified, the debug adapter is free to do whatever it
      // thinks is best. The attribute is only honored by a debug adapter if the
      // corresponding capability `supportTerminateDebuggee` is true.
      optional<boolean> terminateDebuggee;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(DisconnectRequest);

   // Response to `configurationDone` request. This is just an acknowledgement, so
   // no body field is required.
   struct ConfigurationDoneResponse : public Response {};

   DAP_DECLARE_STRUCT_TYPEINFO(ConfigurationDoneResponse);

   // This request indicates that the client has finished initialization of the
   // debug adapter. So it is the last request in the sequence of configuration
   // requests (which was started by the `initialized` event). Clients should only
   // call this request if the corresponding capability
   // `supportsConfigurationDoneRequest` is true.
   struct ConfigurationDoneRequest : public Request {
      using Response = ConfigurationDoneResponse;
   };

   DAP_DECLARE_STRUCT_TYPEINFO(ConfigurationDoneRequest);
}

#endif